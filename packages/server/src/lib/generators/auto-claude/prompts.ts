import { AutoClaudePrompt } from '../../types/auto-claude';

interface PromptsOptions {
  prompts: AutoClaudePrompt[];
  injectionContext?: {
    specDirectory?: string;
    projectContext?: string;
    mcpDocumentation?: string;
  };
}

interface GeneratedPromptFile {
  path: string;
  content: string;
}

/**
 * Generates prompts/*.md files with injection point replacement
 */
export function generateAutoClaudePrompts(options: PromptsOptions): GeneratedPromptFile[] {
  const { prompts, injectionContext = {} } = options;
  const generatedFiles: GeneratedPromptFile[] = [];

  for (const prompt of prompts) {
    const content = processPromptContent(prompt, injectionContext);

    generatedFiles.push({
      path: `prompts/${prompt.agentType}.md`,
      content
    });
  }

  return generatedFiles;
}

/**
 * Processes prompt content by replacing injection points with actual values
 */
function processPromptContent(
  prompt: AutoClaudePrompt,
  injectionContext: PromptsOptions['injectionContext'] = {}
): string {
  let content = prompt.promptContent;

  // Replace injection points if they exist in the prompt content
  if (prompt.injectionPoints) {
    // Replace spec directory injection point
    if (prompt.injectionPoints.specDirectory && injectionContext.specDirectory) {
      content = content.replace(
        /\{\{specDirectory\}\}/g,
        injectionContext.specDirectory
      );
    }

    // Replace project context injection point
    if (prompt.injectionPoints.projectContext && injectionContext.projectContext) {
      content = content.replace(
        /\{\{projectContext\}\}/g,
        injectionContext.projectContext
      );
    }

    // Replace MCP documentation injection point
    if (prompt.injectionPoints.mcpDocumentation && injectionContext.mcpDocumentation) {
      content = content.replace(
        /\{\{mcpDocumentation\}\}/g,
        injectionContext.mcpDocumentation
      );
    }
  }

  // Remove any remaining unresolved injection points
  content = content.replace(/\{\{[^}]+\}\}/g, '<!-- Injection point not resolved -->');

  // Ensure proper markdown formatting with header comment
  const lines = content.split('\n');
  const hasGeneratedComment = lines.some(line =>
    line.includes('Generated by Claude Code Config Manager')
  );

  if (!hasGeneratedComment) {
    const headerComment = [
      '<!-- Generated by Claude Code Config Manager -->',
      '<!-- Do not edit manually - sync from CCM to update -->',
      ''
    ];

    // Insert after any existing front matter or at the beginning
    const frontMatterEnd = findFrontMatterEnd(lines);
    lines.splice(frontMatterEnd, 0, ...headerComment);
  }

  return lines.join('\n');
}

/**
 * Finds the end of YAML front matter in markdown content
 */
function findFrontMatterEnd(lines: string[]): number {
  if (lines.length === 0 || lines[0].trim() !== '---') {
    return 0;
  }

  for (let i = 1; i < lines.length; i++) {
    if (lines[i].trim() === '---') {
      return i + 1;
    }
  }

  // If no closing --- found, assume no front matter
  return 0;
}

/**
 * Helper function to validate prompt content and injection points
 */
export function validatePromptContent(prompt: AutoClaudePrompt): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  // Validate required fields
  if (!prompt.agentType || prompt.agentType.trim() === '') {
    errors.push('Agent type is required');
  }

  if (!prompt.promptContent || prompt.promptContent.trim() === '') {
    errors.push('Prompt content is required');
  }

  // Validate agent type format (alphanumeric with underscores)
  if (prompt.agentType && !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(prompt.agentType)) {
    errors.push('Agent type must be alphanumeric with underscores only');
  }

  // Check for injection point placeholders in content
  const injectionPointPattern = /\{\{([^}]+)\}\}/g;
  const foundInjectionPoints = new Set<string>();
  let match;

  while ((match = injectionPointPattern.exec(prompt.promptContent)) !== null) {
    foundInjectionPoints.add(match[1]);
  }

  // Validate that declared injection points match those found in content
  if (prompt.injectionPoints) {
    const declaredPoints = new Set<string>();

    if (prompt.injectionPoints.specDirectory) {
      declaredPoints.add('specDirectory');
    }
    if (prompt.injectionPoints.projectContext) {
      declaredPoints.add('projectContext');
    }
    if (prompt.injectionPoints.mcpDocumentation) {
      declaredPoints.add('mcpDocumentation');
    }

    // Check for undeclared injection points in content
    for (const foundPoint of foundInjectionPoints) {
      if (!declaredPoints.has(foundPoint)) {
        errors.push(`Injection point '${foundPoint}' found in content but not declared in injectionPoints`);
      }
    }

    // Check for declared injection points not found in content
    for (const declaredPoint of declaredPoints) {
      if (!foundInjectionPoints.has(declaredPoint)) {
        errors.push(`Injection point '${declaredPoint}' declared but not found in content`);
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Helper function to validate an array of prompts
 */
export function validatePrompts(prompts: AutoClaudePrompt[]): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  const agentTypes = new Set<string>();

  for (const prompt of prompts) {
    // Validate individual prompt
    const validation = validatePromptContent(prompt);
    if (!validation.valid) {
      errors.push(`Prompt for '${prompt.agentType}': ${validation.errors.join(', ')}`);
    }

    // Check for duplicate agent types
    if (agentTypes.has(prompt.agentType)) {
      errors.push(`Duplicate agent type '${prompt.agentType}' found`);
    }
    agentTypes.add(prompt.agentType);
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Helper function to get default injection context
 */
export function getDefaultInjectionContext(): NonNullable<PromptsOptions['injectionContext']> {
  return {
    specDirectory: './.auto-claude/specs/current',
    projectContext: '# Project Analysis\n\n*Project context will be generated during execution*',
    mcpDocumentation: '# MCP Server Documentation\n\n*MCP documentation will be loaded based on enabled servers*'
  };
}

/**
 * Helper function to extract injection points from prompt content
 */
export function extractInjectionPoints(promptContent: string): string[] {
  const injectionPointPattern = /\{\{([^}]+)\}\}/g;
  const points: string[] = [];
  let match;

  while ((match = injectionPointPattern.exec(promptContent)) !== null) {
    if (!points.includes(match[1])) {
      points.push(match[1]);
    }
  }

  return points;
}