# CCM v3.2 Terminal Prompts

Copy-paste these prompts into each terminal to start parallel implementation.

---

## Terminal 1 — Database + Server APIs

```
AUTONOMOUS MODE: Do not ask for confirmation or approval. Never ask "Do you want to..." - just do it. Make reasonable assumptions when information is missing. Only stop if completely blocked and unable to proceed. Prefer action over asking.

I'm working on CCM v3.2 Scheduled Optimization. I'm Terminal 1 of 3, focused on DATABASE + SERVER APIs.

Read CCM-V3.2-SCHEDULED-OPTIMIZATION-DESIGN.md for full context.

My tasks (in order):

1. Add 3 new Prisma models to packages/server/prisma/schema.prisma:
   - ScheduledTask (scheduled automation tasks)
   - TaskExecution (execution history)
   - WebhookConfig (notification webhooks)
   - Update Machine model with relationships (scheduledTasks, taskExecutions, webhookConfigs)

2. Run database push: pnpm --filter server db:push

3. Create API: packages/server/src/app/api/scheduler/tasks/route.ts
   - GET: List scheduled tasks with filtering
   - POST: Create new scheduled task

4. Create API: packages/server/src/app/api/scheduler/tasks/[id]/route.ts
   - GET: Get task details with recent executions
   - PATCH: Update task
   - DELETE: Delete task

5. Create API: packages/server/src/app/api/scheduler/tasks/[id]/run/route.ts
   - POST: Manually trigger task execution

6. Create API: packages/server/src/app/api/scheduler/executions/route.ts
   - GET: List execution history with pagination

7. Create API: packages/server/src/app/api/scheduler/executions/[id]/route.ts
   - GET: Get execution details
   - POST: Retry failed execution

8. Create API: packages/server/src/app/api/scheduler/webhooks/route.ts
   - GET: List webhook configs
   - POST: Create new webhook

9. Create API: packages/server/src/app/api/scheduler/webhooks/[id]/route.ts
   - GET: Get webhook details
   - PATCH: Update webhook
   - DELETE: Delete webhook

10. Create API: packages/server/src/app/api/scheduler/webhooks/[id]/test/route.ts
    - POST: Send test notification

11. Create API: packages/server/src/app/api/scheduler/status/route.ts
    - GET: Scheduler status, next runs, active tasks

12. Create API: packages/server/src/app/api/scheduler/upcoming/route.ts
    - GET: Tasks scheduled to run in next N hours

DO NOT touch: packages/server/src/lib/*, packages/server/src/components/*, packages/cli/*

The API routes should import from '@/lib/scheduler' for business logic (Terminal 2 will create these). For now, create the route structure and use placeholder logic that can be connected later. Use patterns from existing routes like /api/context/*.

Start with task 1.
```

---

## Terminal 2 — Scheduler Engine

```
AUTONOMOUS MODE: Do not ask for confirmation or approval. Never ask "Do you want to..." - just do it. Make reasonable assumptions when information is missing. Only stop if completely blocked and unable to proceed. Prefer action over asking.

I'm working on CCM v3.2 Scheduled Optimization. I'm Terminal 2 of 3, focused on SCHEDULER ENGINE.

Read CCM-V3.2-SCHEDULED-OPTIMIZATION-DESIGN.md for full context.

My tasks (in order):

1. Create packages/server/src/lib/scheduler/runner.ts
   - SchedulerRunner class with start/stop methods
   - checkDueTasks() - find and execute due tasks
   - executeTask() - run a single task
   - calculateNextRun() - compute next execution time
   - Task queue management with concurrency limits

2. Create packages/server/src/lib/scheduler/triggers.ts
   - Cron expression parser (use cron-parser or implement simple version)
   - getNextCronRun() - calculate next run from cron expression
   - ThresholdEvaluator class
   - evaluateThreshold() - check if metric crosses threshold
   - getMetricValue() - get current value for a metric

3. Create packages/server/src/lib/scheduler/webhooks.ts
   - WebhookNotifier class
   - notify() - send notifications to webhooks
   - formatSlackPayload() - Slack message format
   - formatDiscordPayload() - Discord embed format
   - formatN8nPayload() - n8n trigger format
   - formatGenericPayload() - generic JSON format
   - testWebhook() - send test notification

4. Create packages/server/src/lib/scheduler/task-handlers.ts
   - executeAnalyzeTask() - run context analysis using @/lib/context
   - executeOptimizeTask() - run optimization using @/lib/context
   - executeHealthCheckTask() - generate health report
   - TaskResult interface and error handling

5. Create packages/server/src/lib/scheduler/index.ts
   - Export all public APIs
   - Create singleton scheduler instance
   - Utility functions for common operations

6. Integrate scheduler with v3.1 context optimizer
   - Import analyze, optimize from @/lib/context
   - Store results in ContextAnalysis table
   - Create archives in ContextArchive table

7. Add scheduler initialization hook (optional if time permits)
   - Start scheduler on server startup
   - Graceful shutdown handling

DO NOT touch: packages/server/src/app/api/*, packages/server/src/components/*, packages/cli/*

Reference @/lib/context for how the intelligence engine is structured. Use similar patterns.

Start with task 1.
```

---

## Terminal 3 — UI + CLI

```
AUTONOMOUS MODE: Do not ask for confirmation or approval. Never ask "Do you want to..." - just do it. Make reasonable assumptions when information is missing. Only stop if completely blocked and unable to proceed. Prefer action over asking.

I'm working on CCM v3.2 Scheduled Optimization. I'm Terminal 3 of 3, focused on UI + CLI.

Read CCM-V3.2-SCHEDULED-OPTIMIZATION-DESIGN.md for full context.

My tasks (in order):

1. Create packages/server/src/components/scheduler/ScheduleCard.tsx
   - Display scheduled task with status, schedule, last/next run
   - Enable/disable toggle
   - Edit and Run buttons
   - Visual indicator for task type (analyze, optimize, health_check)

2. Create packages/server/src/components/scheduler/TaskHistory.tsx
   - List of recent task executions
   - Status indicators (success, failed, running)
   - Duration, projects processed, tokens saved
   - Expandable details view

3. Create packages/server/src/components/scheduler/WebhookConfigCard.tsx
   - Display webhook with type icon (Slack, Discord, n8n)
   - Status indicator and last used
   - Test button
   - Edit/Delete actions

4. Create packages/server/src/components/scheduler/CreateTaskDialog.tsx
   - Form for creating new scheduled task
   - Task type selection
   - Schedule type (cron, interval, threshold)
   - Cron expression input with preview
   - Threshold configuration
   - Project scope selection
   - Notification settings

5. Create packages/server/src/components/scheduler/SchedulerStats.tsx
   - Active tasks count
   - Executions today
   - Success/failure rate
   - Tokens saved today

6. Create packages/server/src/components/scheduler/index.ts
   - Export all components

7. Create packages/server/src/app/scheduler/page.tsx
   - Main scheduler dashboard
   - Stats overview
   - Task list with ScheduleCard
   - Execution history with TaskHistory
   - Webhook management section

8. Update packages/server/src/components/layout/sidebar.tsx
   - Add "Scheduler" link to navigation
   - Use Clock or Calendar icon

9. Create packages/cli/src/commands/schedule.ts
   - schedule list - List all scheduled tasks
   - schedule create - Interactive task creation
   - schedule enable/disable <id> - Toggle task
   - schedule delete <id> - Delete task
   - schedule run <id> - Manually trigger task
   - schedule history - Recent executions
   - schedule webhooks list/add/test/delete - Webhook management
   - schedule status - Scheduler status
   - schedule upcoming - Upcoming tasks
   - schedule quick <preset> - Quick setup (daily-analysis, weekly-optimize, threshold-alert)

10. Update packages/cli/src/commands/index.ts
    - Register schedule command

DO NOT touch: packages/server/prisma/*, packages/server/src/lib/scheduler/*

Use existing components from /components/context and /components/recommendations as reference for styling and patterns. Use shadcn/ui components.

Start with task 1.
```

---

## Quick Start

1. Open 3 terminal windows
2. In each terminal: `cd /Users/calebbolden/Projects/claude-code-config-manager && claude --dangerously-skip-permissions`
3. Paste the corresponding prompt into each terminal
4. Let them run in parallel

## Coordination Notes

- Terminal 1 creates the database schema and API structure
- Terminal 2 creates the business logic that APIs will call
- Terminal 3 creates the user interfaces that call the APIs
- APIs use placeholder logic until Terminal 2 completes, then can be wired up
- All terminals can work simultaneously without conflicts
