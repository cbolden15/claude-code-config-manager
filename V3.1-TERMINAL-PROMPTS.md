# CCM v3.1 Context Optimizer - Terminal Prompts

Copy and paste each prompt into its respective terminal.

---

## Terminal 1 — Database + Server APIs

```
AUTONOMOUS MODE: Do not ask for confirmation or approval. Never ask "Do you want to..." - just do it. Make reasonable assumptions when information is missing. Only stop if completely blocked and unable to proceed. Prefer action over asking.

I'm working on CCM v3.1 Context Optimizer. I'm Terminal 1 of 3, focused on DATABASE + SERVER APIs.

Read CCM-V3.1-CONTEXT-OPTIMIZER-DESIGN.md for full context.

My tasks (in order):

1. Add 3 new Prisma models to packages/server/prisma/schema.prisma:
   - ContextAnalysis (analysis results for CLAUDE.md files)
   - ContextArchive (archived content from optimizations)
   - ContextOptimizationRule (user-configurable rules)
   - Update Machine model with relationships (contextAnalyses, contextArchives, optimizationRules)

2. Run database push: pnpm --filter server db:push (or npx prisma db push)

3. Create API: packages/server/src/app/api/context/analyze/route.ts
   - POST: Analyze a CLAUDE.md file, return sections and issues
   - GET: Get latest analysis for a project

4. Create API: packages/server/src/app/api/context/analyze/[id]/route.ts
   - GET: Get specific analysis with full details

5. Create API: packages/server/src/app/api/context/optimize/route.ts
   - POST: Apply optimization plan to CLAUDE.md

6. Create API: packages/server/src/app/api/context/optimize/preview/route.ts
   - POST: Preview optimization changes without applying

7. Create API: packages/server/src/app/api/context/archives/route.ts
   - GET: List archives for a project

8. Create API: packages/server/src/app/api/context/archives/[id]/route.ts
   - GET: Get archive content

9. Create API: packages/server/src/app/api/context/archives/restore/route.ts
   - POST: Restore content from archive

10. Create API: packages/server/src/app/api/context/rules/route.ts
    - GET: List optimization rules
    - POST: Create new rule

11. Create API: packages/server/src/app/api/context/rules/[id]/route.ts
    - GET: Get rule by ID
    - PATCH: Update rule
    - DELETE: Delete rule

DO NOT touch: packages/server/src/lib/*, packages/server/src/components/*, packages/cli/*

The API routes should import from '@/lib/context' for business logic (Terminal 2 will create these). For now, create the route structure and use placeholder logic that can be connected later. Use patterns from existing routes like /api/recommendations/*.

Start with task 1.
```

---

## Terminal 2 — Intelligence Engine

```
AUTONOMOUS MODE: Do not ask for confirmation or approval. Never ask "Do you want to..." - just do it. Make reasonable assumptions when information is missing. Only stop if completely blocked and unable to proceed. Prefer action over asking.

I'm working on CCM v3.1 Context Optimizer. I'm Terminal 2 of 3, focused on INTELLIGENCE ENGINE.

Read CCM-V3.1-CONTEXT-OPTIMIZER-DESIGN.md for full context.

My tasks (in order):

1. Create packages/server/src/lib/context/analyzer.ts
   - parseClaudeMd(content: string): Parse CLAUDE.md into sections
   - countTokens(text: string): Estimate token count (~4 chars per token)
   - analyzeFile(filePath: string): Full analysis returning sections, line counts, token estimates
   - detectStaleDates(content: string): Find outdated date references

2. Create packages/server/src/lib/context/classifier.ts
   - SectionType enum: project_overview, current_phase, technology_stack, commands, conventions, completed_work, work_sessions, testing, data_model, notes, unknown
   - classifySection(name: string, content: string): Determine section type
   - assessActionability(section): Return 'high' | 'medium' | 'low'
   - assessStaleness(section): Return 0-1 staleness score

3. Create packages/server/src/lib/context/detector.ts
   - IssueType enum: oversized_section, completed_work_verbose, outdated_reference, duplicate_content, stale_dates, low_actionability, excessive_examples
   - detectIssues(sections: ClassifiedSection[]): Find all optimization opportunities
   - calculateSeverity(issue): Return 'high' | 'medium' | 'low'
   - estimateTokenSavings(issue): Calculate potential savings

4. Create packages/server/src/lib/context/optimizer.ts
   - Strategy type: 'conservative' | 'moderate' | 'aggressive' | 'custom'
   - generatePlan(analysis, strategy): Create optimization plan with actions
   - applyPlan(plan, content): Apply optimizations, return new content
   - ActionType: 'archive' | 'condense' | 'remove' | 'move' | 'dedupe'

5. Create packages/server/src/lib/context/archiver.ts
   - createArchive(section, projectPath): Generate archive file content
   - generateSummary(section, maxLines): Condense section to summary
   - getArchivePath(projectPath, sectionName): Generate archive file path
   - formatArchiveReference(archivePath, lineCount): Create reference text

6. Create packages/server/src/lib/context/rules.ts
   - DEFAULT_RULES: Pre-configured optimization rules (from design doc)
   - applyRules(sections, rules): Apply rules to generate issues
   - matchesPattern(section, rule): Check if section matches rule

7. Create packages/server/src/lib/context/index.ts
   - Export all public APIs
   - Create main analyze() and optimize() functions that orchestrate the pipeline

8. Update packages/server/src/lib/health/calculator.ts
   - Add context score calculation based on CLAUDE.md optimization level
   - Include in overall health score (add contextOptimizationScore field)

DO NOT touch: packages/server/src/app/api/*, packages/server/src/components/*, packages/cli/*

Follow patterns from existing lib code like packages/server/src/lib/recommendations/. Use TypeScript interfaces for all data structures. Include JSDoc comments for public functions.

Start with task 1.
```

---

## Terminal 3 — UI + CLI

```
AUTONOMOUS MODE: Do not ask for confirmation or approval. Never ask "Do you want to..." - just do it. Make reasonable assumptions when information is missing. Only stop if completely blocked and unable to proceed. Prefer action over asking.

I'm working on CCM v3.1 Context Optimizer. I'm Terminal 3 of 3, focused on UI + CLI.

Read CCM-V3.1-CONTEXT-OPTIMIZER-DESIGN.md for full context.

My tasks (in order):

1. Create packages/server/src/components/context/ContextHealthCard.tsx
   - Display optimization score (0-100) with progress bar
   - Show line count, token estimate, last analyzed time
   - "Analyze" button to trigger fresh analysis
   - Use shadcn/ui components (Card, Progress, Button)

2. Create packages/server/src/components/context/OptimizationIssueCard.tsx
   - Display single optimization opportunity
   - Show severity badge (high/medium/low with colors)
   - Show section name, description, estimated savings
   - "Preview" and "Apply" buttons
   - Expandable to show before/after preview

3. Create packages/server/src/components/context/ArchiveList.tsx
   - List archived content with date, source file, line count
   - "View" button to see archive content
   - "Restore" button to restore from archive
   - Empty state when no archives

4. Create packages/server/src/components/context/OptimizationPreviewDialog.tsx
   - Modal showing before/after diff
   - Summary of changes (lines removed, tokens saved)
   - "Cancel" and "Apply" buttons
   - Use shadcn Dialog component

5. Create packages/server/src/app/context/page.tsx
   - Main context optimization dashboard
   - Layout: Health card at top, issues list, archives section
   - "Analyze" and "Apply All" action buttons
   - Fetch data from /api/context/* endpoints
   - Loading and error states

6. Update packages/server/src/components/layout/sidebar.tsx
   - Add "Context" link to navigation (icon: FileText or Sparkles)
   - Place after "Recommendations" in the menu

7. Create packages/cli/src/commands/context.ts
   - ccm context analyze [--project <path>] [--verbose]
   - ccm context optimize [--dry-run] [--strategy <name>] [--auto-approve]
   - ccm context status
   - ccm context archives [list|show|restore] [id]
   - ccm context rules [list|add|disable] [id]
   - Use commander.js patterns from existing commands
   - Pretty print with colors (chalk) and tables

8. Update packages/cli/src/commands/index.ts
   - Import and register context commands

9. Create packages/server/src/components/context/index.ts
   - Export all context components

10. Add context_optimization as recommendation type:
    - Update packages/server/src/components/recommendations/RecommendationCard.tsx to handle type="context_optimization"
    - Show appropriate icon and action button for context recommendations

DO NOT touch: packages/server/prisma/*, packages/server/src/lib/context/*

Follow patterns from existing UI components in packages/server/src/components/recommendations/. Use the existing API client patterns from packages/cli/src/lib/api.ts for CLI.

Start with task 1.
```

---

## Startup Instructions

Open 3 terminal windows and run in each:

```bash
cd /Users/calebbolden/Projects/claude-code-config-manager && claude --dangerously-skip-permissions
```

Then paste the appropriate prompt into each terminal.

---

## Coordination Notes

- **Terminal 1** creates API routes with placeholder logic
- **Terminal 2** creates the actual business logic in lib/context/
- **Terminal 3** creates UI that calls the APIs

After all terminals complete:
1. Terminal 1 should update API routes to import from lib/context/
2. Run full integration test
3. Test on CCM's own CLAUDE.md

---

## Verification Checklist

After implementation, verify:

- [ ] `pnpm --filter server build` succeeds
- [ ] Database has new tables (ContextAnalysis, ContextArchive, ContextOptimizationRule)
- [ ] API routes respond (curl test)
- [ ] UI page loads at /context
- [ ] CLI commands work (`ccm context --help`)
- [ ] Analyze CCM's own CLAUDE.md as integration test
