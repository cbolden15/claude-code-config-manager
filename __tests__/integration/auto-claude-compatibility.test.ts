#!/usr/bin/env node

/**
 * Auto-Claude Compatibility Integration Test
 *
 * This test verifies that files generated by CCM are compatible with actual Auto-Claude installations.
 * It validates the format, structure, and content of generated configurations to ensure they work
 * correctly when used by Auto-Claude's runtime system.
 *
 * Tests:
 * 1. Environment file compatibility (.auto-claude/.env)
 * 2. Task metadata compatibility (task_metadata.json)
 * 3. Agent configs compatibility (AGENT_CONFIGS.json)
 * 4. Prompts compatibility (prompts/*.md)
 * 5. Full workflow integration with mock Auto-Claude structure
 */

import assert from 'node:assert';
import fs from 'node:fs/promises';
import path from 'node:path';
import os from 'node:os';

// Import CCM generators
import {
  generateAutoClaudeEnv,
  getDefaultAutoClaudeProjectConfig
} from '../../packages/server/src/lib/generators/auto-claude/env-file.ts';
import {
  generateTaskMetadata,
  getDefaultModelProfile,
  getCostOptimizedModelProfile,
  getQualityFocusedModelProfile
} from '../../packages/server/src/lib/generators/auto-claude/model-profile.ts';
import {
  generateAutoClaudePrompts
} from '../../packages/server/src/lib/generators/auto-claude/prompts.ts';
import {
  generateAgentConfigs,
  getDefaultAgentConfigs
} from '../../packages/server/src/lib/generators/auto-claude/agent-configs.ts';

// Import types
import type {
  AutoClaudeAgentConfig,
  AutoClaudePrompt,
  AutoClaudeModelProfile,
  AutoClaudeProjectConfig
} from '../../packages/shared/src/types/auto-claude.ts';

interface CompatibilityTestContext {
  tempDir: string;
  autoClaudeDir: string;
  generatedFiles: {
    envFile: string;
    taskMetadata: string;
    agentConfigs: string;
    prompts: Record<string, string>;
  };
}

/**
 * Test utilities for validation
 */
function assertFileExists(filePath: string, message?: string) {
  return fs.access(filePath).catch(() => {
    throw new Error(message || `File should exist: ${filePath}`);
  });
}

function assertValidJSON(content: string, message?: string) {
  try {
    JSON.parse(content);
  } catch (error) {
    throw new Error(message || `Content should be valid JSON: ${error}`);
  }
}

function assertValidEnvFormat(content: string) {
  const lines = content.split('\n').filter(line => line.trim() && !line.startsWith('#'));

  for (const line of lines) {
    assert(
      line.includes('='),
      `Environment line should contain '=': ${line}`
    );

    const [key] = line.split('=');
    assert(
      key && key.trim().length > 0,
      `Environment key should not be empty: ${line}`
    );
  }
}

function assertAutoClaudeEnvStructure(content: string) {
  // Required Auto-Claude environment variables
  const requiredVars = [
    'AUTO_CLAUDE_ENABLED',
    'ANTHROPIC_API_KEY'
  ];

  const requiredMcpToggles = [
    'CONTEXT7_ENABLED',
    'LINEAR_MCP_ENABLED',
    'ELECTRON_MCP_ENABLED',
    'PUPPETEER_MCP_ENABLED',
    'GRAPHITI_ENABLED'
  ];

  for (const varName of requiredVars) {
    assert(
      content.includes(`${varName}=`),
      `Environment should contain ${varName}`
    );
  }

  for (const toggle of requiredMcpToggles) {
    assert(
      content.includes(`${toggle}=`),
      `Environment should contain MCP toggle ${toggle}`
    );
  }
}

function assertTaskMetadataStructure(content: string) {
  const parsed = JSON.parse(content);

  // Required Auto-Claude task metadata structure
  assert(parsed.models, 'Task metadata should have models');
  assert(parsed.thinking, 'Task metadata should have thinking');

  const requiredPhases = ['spec', 'planning', 'coding', 'qa'];

  for (const phase of requiredPhases) {
    assert(
      phase in parsed.models,
      `models should contain ${phase}`
    );
    assert(
      phase in parsed.thinking,
      `thinking should contain ${phase}`
    );
  }

  // Validate model values
  const validModels = ['opus', 'sonnet', 'haiku'];
  const validThinking = ['none', 'low', 'medium', 'high', 'ultrathink'];

  for (const phase of requiredPhases) {
    assert(
      validModels.includes(parsed.models[phase]),
      `Invalid model for ${phase}: ${parsed.models[phase]}`
    );
    assert(
      validThinking.includes(parsed.thinking[phase]),
      `Invalid thinking level for ${phase}: ${parsed.thinking[phase]}`
    );
  }
}

function assertAgentConfigsStructure(content: string) {
  const parsed = JSON.parse(content);

  assert(typeof parsed === 'object', 'Agent configs should be an object');
  assert(Object.keys(parsed).length > 0, 'Agent configs should not be empty');

  // Check each agent config follows Auto-Claude structure
  for (const [agentType, config] of Object.entries(parsed as Record<string, any>)) {
    assert(typeof config === 'object', `Config for ${agentType} should be an object`);

    const requiredFields = ['agentType', 'tools', 'mcpServers', 'thinkingDefault'];
    for (const field of requiredFields) {
      assert(
        field in config,
        `Agent config ${agentType} should have ${field}`
      );
    }

    // Validate field types
    assert(
      config.agentType === agentType,
      `Agent type should match key: ${agentType}`
    );
    assert(
      Array.isArray(config.tools),
      `Tools should be array for ${agentType}`
    );
    assert(
      Array.isArray(config.mcpServers),
      `MCP servers should be array for ${agentType}`
    );
    assert(
      ['none', 'low', 'medium', 'high', 'ultrathink'].includes(config.thinkingDefault),
      `Invalid thinking level for ${agentType}: ${config.thinkingDefault}`
    );
  }
}

function assertPromptStructure(content: string, agentType: string) {
  // Basic markdown validation
  assert(
    content.trim().length > 0,
    `Prompt for ${agentType} should not be empty`
  );

  // Should look like a prompt (contains some expected keywords)
  const promptKeywords = ['agent', 'you are', 'your', 'responsibilities', 'context'];
  const lowerContent = content.toLowerCase();

  const hasPromptContent = promptKeywords.some(keyword =>
    lowerContent.includes(keyword)
  );

  assert(
    hasPromptContent,
    `Prompt for ${agentType} should contain prompt-like content`
  );

  // Check for injection points if present
  const injectionPoints = ['{{specDirectory}}', '{{projectContext}}', '{{mcpDocumentation}}'];
  for (const point of injectionPoints) {
    if (content.includes(point)) {
      // Validate injection point is properly formatted
      assert(
        content.includes(point),
        `Injection point ${point} should be properly formatted`
      );
    }
  }
}

/**
 * Setup mock Auto-Claude directory structure for testing
 */
async function setupMockAutoClaudeStructure(tempDir: string): Promise<string> {
  const autoClaudeDir = path.join(tempDir, 'mock-auto-claude');

  // Create the expected Auto-Claude directory structure
  const directories = [
    'apps/backend/prompts',
    '.auto-claude'
  ];

  for (const dir of directories) {
    await fs.mkdir(path.join(autoClaudeDir, dir), { recursive: true });
  }

  // Create a basic package.json to simulate Auto-Claude installation
  const packageJson = {
    name: 'auto-claude',
    version: '2.1.0',
    description: 'Auto-Claude compatibility test installation'
  };

  await fs.writeFile(
    path.join(autoClaudeDir, 'package.json'),
    JSON.stringify(packageJson, null, 2)
  );

  return autoClaudeDir;
}

/**
 * TEST 1: Environment file compatibility
 */
async function testEnvironmentFileCompatibility(context: CompatibilityTestContext): Promise<void> {
  console.log('Test 1: Environment file compatibility');

  // Test with default configuration
  const projectConfig = getDefaultAutoClaudeProjectConfig();
  const settings = {
    anthropicApiKey: 'test-anthropic-key-123',
    linearApiKey: 'test-linear-key',
    githubToken: 'test-github-token'
  };

  // Generate environment file
  const envContent = generateAutoClaudeEnv({ projectConfig, settings });
  context.generatedFiles.envFile = envContent;

  // Write to mock Auto-Claude structure
  const envPath = path.join(context.autoClaudeDir, '.auto-claude', '.env');
  await fs.writeFile(envPath, envContent);

  // Validate format
  assertValidEnvFormat(envContent);
  assertAutoClaudeEnvStructure(envContent);

  // Validate file exists and is readable
  await assertFileExists(envPath);
  const readContent = await fs.readFile(envPath, 'utf-8');
  assert.strictEqual(readContent, envContent, 'Written file should match generated content');

  // Validate specific Auto-Claude compatibility requirements
  assert(envContent.includes('AUTO_CLAUDE_ENABLED=true'), 'Should enable Auto-Claude');
  assert(envContent.includes('ANTHROPIC_API_KEY=test-anthropic-key-123'), 'Should include API key');
  assert(envContent.includes('CONTEXT7_ENABLED=true'), 'Should enable Context7 by default');

  console.log('  ‚úì Environment file format is valid');
  console.log('  ‚úì Auto-Claude structure requirements met');
  console.log('  ‚úì File can be written and read correctly');
  console.log('');
}

/**
 * TEST 2: Task metadata compatibility
 */
async function testTaskMetadataCompatibility(context: CompatibilityTestContext): Promise<void> {
  console.log('Test 2: Task metadata compatibility');

  // Test different model profiles
  const profiles = [
    { name: 'default', profile: getDefaultModelProfile() },
    { name: 'cost-optimized', profile: getCostOptimizedModelProfile() },
    { name: 'quality-focused', profile: getQualityFocusedModelProfile() }
  ];

  for (const { name, profile } of profiles) {
    console.log(`  Testing ${name} profile...`);

    const metadata = generateTaskMetadata({ modelProfile: profile });

    // Validate JSON format
    assertValidJSON(metadata);
    assertTaskMetadataStructure(metadata);

    // Write and verify file
    const metadataPath = path.join(context.autoClaudeDir, `task_metadata_${name}.json`);
    await fs.writeFile(metadataPath, metadata);
    await assertFileExists(metadataPath);

    // Validate specific profile characteristics
    const parsed = JSON.parse(metadata);
    assert(Object.keys(parsed.models).length === 4, 'Should have 4 phases');
    assert(Object.keys(parsed.thinking).length === 4, 'Should have 4 phases');

    console.log(`    ‚úì ${name} profile generates valid metadata`);
  }

  // Store default for context
  context.generatedFiles.taskMetadata = generateTaskMetadata({ modelProfile: getDefaultModelProfile() });

  console.log('  ‚úì Task metadata format is Auto-Claude compatible');
  console.log('  ‚úì All model profiles generate valid configurations');
  console.log('');
}

/**
 * TEST 3: Agent configs compatibility
 */
async function testAgentConfigsCompatibility(context: CompatibilityTestContext): Promise<void> {
  console.log('Test 3: Agent configs compatibility');

  // Get default agent configurations
  const agentConfigs = getDefaultAgentConfigs();

  // Generate agent configs JSON
  const agentConfigsContent = generateAgentConfigs({ agentConfigs });
  context.generatedFiles.agentConfigs = agentConfigsContent;

  // Validate JSON format
  assertValidJSON(agentConfigsContent);
  assertAgentConfigsStructure(agentConfigsContent);

  // Write to mock Auto-Claude structure
  const configsPath = path.join(context.autoClaudeDir, 'AGENT_CONFIGS.json');
  await fs.writeFile(configsPath, agentConfigsContent);
  await assertFileExists(configsPath);

  // Validate agent configs content
  const parsed = JSON.parse(agentConfigsContent);
  const agentTypes = Object.keys(parsed);

  assert(agentTypes.length > 0, 'Should have agent configurations');
  assert(agentTypes.includes('coder'), 'Should include coder agent');
  assert(agentTypes.includes('planner'), 'Should include planner agent');

  // Validate specific agent requirements for Auto-Claude
  const coderConfig = parsed.coder;
  assert(coderConfig.tools.includes('Read'), 'Coder should have Read tool');
  assert(coderConfig.tools.includes('Write'), 'Coder should have Write tool');
  assert(coderConfig.tools.includes('Edit'), 'Coder should have Edit tool');
  assert(coderConfig.mcpServers.includes('context7'), 'Coder should use context7');

  console.log(`  ‚úì Generated ${agentTypes.length} agent configurations`);
  console.log('  ‚úì Agent configs structure is Auto-Claude compatible');
  console.log('  ‚úì Required agent types are present');
  console.log('');
}

/**
 * TEST 4: Prompts compatibility
 */
async function testPromptsCompatibility(context: CompatibilityTestContext): Promise<void> {
  console.log('Test 4: Prompts compatibility');

  // Create sample prompts for testing
  const testPrompts: AutoClaudePrompt[] = [
    {
      agentType: 'coder',
      promptContent: `# Coder Agent

You are an expert software engineer focused on implementing high-quality code.

## Context

You have access to the project specification: {{specDirectory}}
Current project context: {{projectContext}}
MCP documentation available: {{mcpDocumentation}}

## Responsibilities

- Write clean, maintainable code
- Follow project patterns and conventions
- Implement comprehensive error handling
- Add appropriate comments and documentation`,
      injectionPoints: {
        specDirectory: true,
        projectContext: true,
        mcpDocumentation: true
      }
    },
    {
      agentType: 'planner',
      promptContent: `# Planner Agent

You are an expert software architect responsible for designing implementation strategies.

## Context

Project specification: {{specDirectory}}
Current context: {{projectContext}}

## Responsibilities

- Design implementation plans
- Consider architectural trade-offs
- Plan file structure and dependencies`,
      injectionPoints: {
        specDirectory: true,
        projectContext: true,
        mcpDocumentation: false
      }
    },
    {
      agentType: 'qa_reviewer',
      promptContent: `# QA Reviewer Agent

You are a quality assurance specialist focused on testing and validation.

## Responsibilities

- Review code quality
- Validate implementations
- Test edge cases
- Ensure requirements are met`,
      injectionPoints: {
        specDirectory: false,
        projectContext: false,
        mcpDocumentation: false
      }
    }
  ];

  // Generate prompts
  const promptFiles = generateAutoClaudePrompts({
    prompts: testPrompts,
    injectionContext: {
      specDirectory: '/test/spec/directory',
      projectContext: 'Test project context for compatibility test',
      mcpDocumentation: 'Available MCP servers: context7, linear'
    }
  });
  context.generatedFiles.prompts = {};

  // Create prompts directory in mock Auto-Claude structure
  const promptsDir = path.join(context.autoClaudeDir, 'apps', 'backend', 'prompts');

  // Write and validate each prompt
  for (const { path: promptPath, content } of promptFiles) {
    const fileName = path.basename(promptPath);
    const agentType = fileName.replace('.md', '');

    // Validate prompt structure
    assertPromptStructure(content, agentType);

    // Write to prompts directory
    const fullPath = path.join(promptsDir, fileName);
    await fs.writeFile(fullPath, content);
    await assertFileExists(fullPath);

    // Store for context
    context.generatedFiles.prompts[agentType] = content;

    // Validate injection point processing
    const promptConfig = testPrompts.find(p => p.agentType === agentType);
    if (promptConfig?.injectionPoints?.specDirectory) {
      assert(
        !content.includes('{{specDirectory}}') && content.includes('/test/spec/directory'),
        `Prompt ${agentType} should have processed {{specDirectory}} injection point`
      );
    }
    if (promptConfig?.injectionPoints?.projectContext) {
      assert(
        !content.includes('{{projectContext}}') && content.includes('Test project context'),
        `Prompt ${agentType} should have processed {{projectContext}} injection point`
      );
    }

    console.log(`    ‚úì ${fileName} generated and validated`);
  }

  console.log(`  ‚úì Generated ${promptFiles.length} prompt files`);
  console.log('  ‚úì Prompts structure is Auto-Claude compatible');
  console.log('  ‚úì Injection points processed correctly');
  console.log('');
}

/**
 * TEST 5: Full workflow integration
 */
async function testFullWorkflowIntegration(context: CompatibilityTestContext): Promise<void> {
  console.log('Test 5: Full workflow integration');

  // Simulate Auto-Claude loading process
  console.log('  Simulating Auto-Claude configuration loading...');

  // Test 5.1: Verify all required files exist
  const requiredFiles = [
    '.auto-claude/.env',
    'AGENT_CONFIGS.json',
    'apps/backend/prompts/coder.md',
    'apps/backend/prompts/planner.md',
    'apps/backend/prompts/qa_reviewer.md'
  ];

  for (const file of requiredFiles) {
    const filePath = path.join(context.autoClaudeDir, file);
    await assertFileExists(filePath);
    console.log(`    ‚úì ${file} exists`);
  }

  // Test 5.2: Validate cross-file consistency
  console.log('  Validating cross-file consistency...');

  // Parse agent configs
  const agentConfigsPath = path.join(context.autoClaudeDir, 'AGENT_CONFIGS.json');
  const agentConfigsContent = await fs.readFile(agentConfigsPath, 'utf-8');
  const agentConfigs = JSON.parse(agentConfigsContent);

  // Check that we have prompts for all agents
  const agentTypes = Object.keys(agentConfigs);
  for (const agentType of agentTypes.slice(0, 3)) { // Test first 3 to avoid file system issues
    const promptPath = path.join(context.autoClaudeDir, 'apps', 'backend', 'prompts', `${agentType}.md`);
    try {
      await assertFileExists(promptPath);
      console.log(`    ‚úì ${agentType} has matching prompt file`);
    } catch {
      console.log(`    ‚ö†Ô∏è ${agentType} prompt file not found (expected for some agents)`);
    }
  }

  // Test 5.3: Validate environment and configs alignment
  const envPath = path.join(context.autoClaudeDir, '.auto-claude', '.env');
  const envContent = await fs.readFile(envPath, 'utf-8');

  assert(envContent.includes('AUTO_CLAUDE_ENABLED=true'), 'Environment should enable Auto-Claude');
  assert(envContent.includes('CONTEXT7_ENABLED=true'), 'Environment should enable Context7');

  // Check that agent configs reference enabled MCP servers
  const hasContext7Agent = agentTypes.some(agentType =>
    agentConfigs[agentType].mcpServers.includes('context7')
  );
  assert(hasContext7Agent, 'At least one agent should use context7 MCP server');

  console.log('  ‚úì Environment and agent configs are aligned');

  // Test 5.4: File size and format validation
  console.log('  Validating file sizes and formats...');

  const fileSizeChecks = [
    { path: '.auto-claude/.env', minSize: 100, maxSize: 10000 },
    { path: 'AGENT_CONFIGS.json', minSize: 100, maxSize: 50000 }
  ];

  for (const { path: relativePath, minSize, maxSize } of fileSizeChecks) {
    const fullPath = path.join(context.autoClaudeDir, relativePath);
    const stats = await fs.stat(fullPath);

    assert(
      stats.size >= minSize,
      `${relativePath} should be at least ${minSize} bytes (got ${stats.size})`
    );
    assert(
      stats.size <= maxSize,
      `${relativePath} should be at most ${maxSize} bytes (got ${stats.size})`
    );

    console.log(`    ‚úì ${relativePath} size: ${stats.size} bytes`);
  }

  console.log('  ‚úì Full workflow integration validated');
  console.log('  ‚úì All files properly structured for Auto-Claude consumption');
  console.log('');
}

/**
 * Cleanup test resources
 */
async function cleanupTestResources(context: CompatibilityTestContext): Promise<void> {
  try {
    await fs.rm(context.tempDir, { recursive: true, force: true });
  } catch (error) {
    // Ignore cleanup errors
    console.log(`Warning: Could not clean up temp directory: ${error}`);
  }
}

/**
 * Main test runner
 */
async function runCompatibilityTests(): Promise<void> {
  console.log('üß™ Auto-Claude Compatibility Integration Tests\n');
  console.log('Testing CCM-generated files work with Auto-Claude installation...\n');

  // Setup test context
  const context: CompatibilityTestContext = {
    tempDir: await fs.mkdtemp(path.join(os.tmpdir(), 'ccm-compat-test-')),
    autoClaudeDir: '',
    generatedFiles: {
      envFile: '',
      taskMetadata: '',
      agentConfigs: '',
      prompts: {}
    }
  };

  try {
    // Setup mock Auto-Claude structure
    console.log('üõ†Ô∏è Setting up mock Auto-Claude installation...');
    context.autoClaudeDir = await setupMockAutoClaudeStructure(context.tempDir);
    console.log(`   ‚úì Mock installation created: ${context.autoClaudeDir}\n`);

    // Run compatibility tests
    await testEnvironmentFileCompatibility(context);
    await testTaskMetadataCompatibility(context);
    await testAgentConfigsCompatibility(context);
    await testPromptsCompatibility(context);
    await testFullWorkflowIntegration(context);

    console.log('üéâ All Auto-Claude Compatibility Tests Passed!\n');
    console.log('‚úÖ CCM-generated files are fully compatible with Auto-Claude:');
    console.log('   ‚Ä¢ Environment files (.auto-claude/.env) ‚úì');
    console.log('   ‚Ä¢ Task metadata (task_metadata.json) ‚úì');
    console.log('   ‚Ä¢ Agent configurations (AGENT_CONFIGS.json) ‚úì');
    console.log('   ‚Ä¢ Prompt files (prompts/*.md) ‚úì');
    console.log('   ‚Ä¢ Full workflow integration ‚úì\n');

  } catch (error) {
    console.error('‚ùå Auto-Claude Compatibility Test Failed:', error);
    throw error;
  } finally {
    // Cleanup test resources
    console.log('üßπ Cleaning up test resources...');
    await cleanupTestResources(context);
    console.log('   ‚úì Cleanup completed\n');
  }
}

// Export for external use
export {
  runCompatibilityTests,
  testEnvironmentFileCompatibility,
  testTaskMetadataCompatibility,
  testAgentConfigsCompatibility,
  testPromptsCompatibility,
  testFullWorkflowIntegration
};

// Run tests if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  runCompatibilityTests().catch((error) => {
    console.error('‚ùå Test execution failed:', error);
    process.exit(1);
  });
}